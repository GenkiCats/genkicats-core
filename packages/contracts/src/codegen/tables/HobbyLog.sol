// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

/* Autogenerated file. Do not edit manually. */

// Import schema type
import { SchemaType } from "@latticexyz/schema-type/src/solidity/SchemaType.sol";

// Import store internals
import { IStore } from "@latticexyz/store/src/IStore.sol";
import { StoreSwitch } from "@latticexyz/store/src/StoreSwitch.sol";
import { StoreCore } from "@latticexyz/store/src/StoreCore.sol";
import { Bytes } from "@latticexyz/store/src/Bytes.sol";
import { Memory } from "@latticexyz/store/src/Memory.sol";
import { SliceLib } from "@latticexyz/store/src/Slice.sol";
import { EncodeArray } from "@latticexyz/store/src/tightcoder/EncodeArray.sol";
import { Schema, SchemaLib } from "@latticexyz/store/src/Schema.sol";
import { PackedCounter, PackedCounterLib } from "@latticexyz/store/src/PackedCounter.sol";

bytes32 constant _tableId = bytes32(abi.encodePacked(bytes16(""), bytes16("HobbyLog")));
bytes32 constant HobbyLogTableId = _tableId;

struct HobbyLogData {
  bytes32 catId;
  bytes32 hobbyId;
  uint8 tier;
  bytes32 tagId;
  uint32 tierTagIndex;
  uint32 dropRate;
  uint256 specialEffect;
  uint32 stepNum;
  uint256 startTime;
  uint256 requestRandBlock;
  uint256 randomSeed;
  uint256 endTime;
  uint256 lastUpdateTime;
  uint8 status;
  uint256 rewardCoins;
  uint32 rewardCatExp;
  uint32 rewardUserExp;
  bytes32[] rewardItems;
}

library HobbyLog {
  /** Get the table's schema */
  function getSchema() internal pure returns (Schema) {
    SchemaType[] memory _schema = new SchemaType[](18);
    _schema[0] = SchemaType.BYTES32;
    _schema[1] = SchemaType.BYTES32;
    _schema[2] = SchemaType.UINT8;
    _schema[3] = SchemaType.BYTES32;
    _schema[4] = SchemaType.UINT32;
    _schema[5] = SchemaType.UINT32;
    _schema[6] = SchemaType.UINT256;
    _schema[7] = SchemaType.UINT32;
    _schema[8] = SchemaType.UINT256;
    _schema[9] = SchemaType.UINT256;
    _schema[10] = SchemaType.UINT256;
    _schema[11] = SchemaType.UINT256;
    _schema[12] = SchemaType.UINT256;
    _schema[13] = SchemaType.UINT8;
    _schema[14] = SchemaType.UINT256;
    _schema[15] = SchemaType.UINT32;
    _schema[16] = SchemaType.UINT32;
    _schema[17] = SchemaType.BYTES32_ARRAY;

    return SchemaLib.encode(_schema);
  }

  function getKeySchema() internal pure returns (Schema) {
    SchemaType[] memory _schema = new SchemaType[](1);
    _schema[0] = SchemaType.BYTES32;

    return SchemaLib.encode(_schema);
  }

  /** Get the table's metadata */
  function getMetadata() internal pure returns (string memory, string[] memory) {
    string[] memory _fieldNames = new string[](18);
    _fieldNames[0] = "catId";
    _fieldNames[1] = "hobbyId";
    _fieldNames[2] = "tier";
    _fieldNames[3] = "tagId";
    _fieldNames[4] = "tierTagIndex";
    _fieldNames[5] = "dropRate";
    _fieldNames[6] = "specialEffect";
    _fieldNames[7] = "stepNum";
    _fieldNames[8] = "startTime";
    _fieldNames[9] = "requestRandBlock";
    _fieldNames[10] = "randomSeed";
    _fieldNames[11] = "endTime";
    _fieldNames[12] = "lastUpdateTime";
    _fieldNames[13] = "status";
    _fieldNames[14] = "rewardCoins";
    _fieldNames[15] = "rewardCatExp";
    _fieldNames[16] = "rewardUserExp";
    _fieldNames[17] = "rewardItems";
    return ("HobbyLog", _fieldNames);
  }

  /** Register the table's schema */
  function registerSchema() internal {
    StoreSwitch.registerSchema(_tableId, getSchema(), getKeySchema());
  }

  /** Register the table's schema (using the specified store) */
  function registerSchema(IStore _store) internal {
    _store.registerSchema(_tableId, getSchema(), getKeySchema());
  }

  /** Set the table's metadata */
  function setMetadata() internal {
    (string memory _tableName, string[] memory _fieldNames) = getMetadata();
    StoreSwitch.setMetadata(_tableId, _tableName, _fieldNames);
  }

  /** Set the table's metadata (using the specified store) */
  function setMetadata(IStore _store) internal {
    (string memory _tableName, string[] memory _fieldNames) = getMetadata();
    _store.setMetadata(_tableId, _tableName, _fieldNames);
  }

  /** Get catId */
  function getCatId(bytes32 logId) internal view returns (bytes32 catId) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = logId;

    bytes memory _blob = StoreSwitch.getField(_tableId, _keyTuple, 0);
    return (Bytes.slice32(_blob, 0));
  }

  /** Get catId (using the specified store) */
  function getCatId(IStore _store, bytes32 logId) internal view returns (bytes32 catId) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = logId;

    bytes memory _blob = _store.getField(_tableId, _keyTuple, 0);
    return (Bytes.slice32(_blob, 0));
  }

  /** Set catId */
  function setCatId(bytes32 logId, bytes32 catId) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = logId;

    StoreSwitch.setField(_tableId, _keyTuple, 0, abi.encodePacked((catId)));
  }

  /** Set catId (using the specified store) */
  function setCatId(IStore _store, bytes32 logId, bytes32 catId) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = logId;

    _store.setField(_tableId, _keyTuple, 0, abi.encodePacked((catId)));
  }

  /** Get hobbyId */
  function getHobbyId(bytes32 logId) internal view returns (bytes32 hobbyId) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = logId;

    bytes memory _blob = StoreSwitch.getField(_tableId, _keyTuple, 1);
    return (Bytes.slice32(_blob, 0));
  }

  /** Get hobbyId (using the specified store) */
  function getHobbyId(IStore _store, bytes32 logId) internal view returns (bytes32 hobbyId) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = logId;

    bytes memory _blob = _store.getField(_tableId, _keyTuple, 1);
    return (Bytes.slice32(_blob, 0));
  }

  /** Set hobbyId */
  function setHobbyId(bytes32 logId, bytes32 hobbyId) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = logId;

    StoreSwitch.setField(_tableId, _keyTuple, 1, abi.encodePacked((hobbyId)));
  }

  /** Set hobbyId (using the specified store) */
  function setHobbyId(IStore _store, bytes32 logId, bytes32 hobbyId) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = logId;

    _store.setField(_tableId, _keyTuple, 1, abi.encodePacked((hobbyId)));
  }

  /** Get tier */
  function getTier(bytes32 logId) internal view returns (uint8 tier) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = logId;

    bytes memory _blob = StoreSwitch.getField(_tableId, _keyTuple, 2);
    return (uint8(Bytes.slice1(_blob, 0)));
  }

  /** Get tier (using the specified store) */
  function getTier(IStore _store, bytes32 logId) internal view returns (uint8 tier) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = logId;

    bytes memory _blob = _store.getField(_tableId, _keyTuple, 2);
    return (uint8(Bytes.slice1(_blob, 0)));
  }

  /** Set tier */
  function setTier(bytes32 logId, uint8 tier) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = logId;

    StoreSwitch.setField(_tableId, _keyTuple, 2, abi.encodePacked((tier)));
  }

  /** Set tier (using the specified store) */
  function setTier(IStore _store, bytes32 logId, uint8 tier) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = logId;

    _store.setField(_tableId, _keyTuple, 2, abi.encodePacked((tier)));
  }

  /** Get tagId */
  function getTagId(bytes32 logId) internal view returns (bytes32 tagId) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = logId;

    bytes memory _blob = StoreSwitch.getField(_tableId, _keyTuple, 3);
    return (Bytes.slice32(_blob, 0));
  }

  /** Get tagId (using the specified store) */
  function getTagId(IStore _store, bytes32 logId) internal view returns (bytes32 tagId) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = logId;

    bytes memory _blob = _store.getField(_tableId, _keyTuple, 3);
    return (Bytes.slice32(_blob, 0));
  }

  /** Set tagId */
  function setTagId(bytes32 logId, bytes32 tagId) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = logId;

    StoreSwitch.setField(_tableId, _keyTuple, 3, abi.encodePacked((tagId)));
  }

  /** Set tagId (using the specified store) */
  function setTagId(IStore _store, bytes32 logId, bytes32 tagId) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = logId;

    _store.setField(_tableId, _keyTuple, 3, abi.encodePacked((tagId)));
  }

  /** Get tierTagIndex */
  function getTierTagIndex(bytes32 logId) internal view returns (uint32 tierTagIndex) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = logId;

    bytes memory _blob = StoreSwitch.getField(_tableId, _keyTuple, 4);
    return (uint32(Bytes.slice4(_blob, 0)));
  }

  /** Get tierTagIndex (using the specified store) */
  function getTierTagIndex(IStore _store, bytes32 logId) internal view returns (uint32 tierTagIndex) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = logId;

    bytes memory _blob = _store.getField(_tableId, _keyTuple, 4);
    return (uint32(Bytes.slice4(_blob, 0)));
  }

  /** Set tierTagIndex */
  function setTierTagIndex(bytes32 logId, uint32 tierTagIndex) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = logId;

    StoreSwitch.setField(_tableId, _keyTuple, 4, abi.encodePacked((tierTagIndex)));
  }

  /** Set tierTagIndex (using the specified store) */
  function setTierTagIndex(IStore _store, bytes32 logId, uint32 tierTagIndex) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = logId;

    _store.setField(_tableId, _keyTuple, 4, abi.encodePacked((tierTagIndex)));
  }

  /** Get dropRate */
  function getDropRate(bytes32 logId) internal view returns (uint32 dropRate) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = logId;

    bytes memory _blob = StoreSwitch.getField(_tableId, _keyTuple, 5);
    return (uint32(Bytes.slice4(_blob, 0)));
  }

  /** Get dropRate (using the specified store) */
  function getDropRate(IStore _store, bytes32 logId) internal view returns (uint32 dropRate) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = logId;

    bytes memory _blob = _store.getField(_tableId, _keyTuple, 5);
    return (uint32(Bytes.slice4(_blob, 0)));
  }

  /** Set dropRate */
  function setDropRate(bytes32 logId, uint32 dropRate) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = logId;

    StoreSwitch.setField(_tableId, _keyTuple, 5, abi.encodePacked((dropRate)));
  }

  /** Set dropRate (using the specified store) */
  function setDropRate(IStore _store, bytes32 logId, uint32 dropRate) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = logId;

    _store.setField(_tableId, _keyTuple, 5, abi.encodePacked((dropRate)));
  }

  /** Get specialEffect */
  function getSpecialEffect(bytes32 logId) internal view returns (uint256 specialEffect) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = logId;

    bytes memory _blob = StoreSwitch.getField(_tableId, _keyTuple, 6);
    return (uint256(Bytes.slice32(_blob, 0)));
  }

  /** Get specialEffect (using the specified store) */
  function getSpecialEffect(IStore _store, bytes32 logId) internal view returns (uint256 specialEffect) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = logId;

    bytes memory _blob = _store.getField(_tableId, _keyTuple, 6);
    return (uint256(Bytes.slice32(_blob, 0)));
  }

  /** Set specialEffect */
  function setSpecialEffect(bytes32 logId, uint256 specialEffect) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = logId;

    StoreSwitch.setField(_tableId, _keyTuple, 6, abi.encodePacked((specialEffect)));
  }

  /** Set specialEffect (using the specified store) */
  function setSpecialEffect(IStore _store, bytes32 logId, uint256 specialEffect) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = logId;

    _store.setField(_tableId, _keyTuple, 6, abi.encodePacked((specialEffect)));
  }

  /** Get stepNum */
  function getStepNum(bytes32 logId) internal view returns (uint32 stepNum) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = logId;

    bytes memory _blob = StoreSwitch.getField(_tableId, _keyTuple, 7);
    return (uint32(Bytes.slice4(_blob, 0)));
  }

  /** Get stepNum (using the specified store) */
  function getStepNum(IStore _store, bytes32 logId) internal view returns (uint32 stepNum) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = logId;

    bytes memory _blob = _store.getField(_tableId, _keyTuple, 7);
    return (uint32(Bytes.slice4(_blob, 0)));
  }

  /** Set stepNum */
  function setStepNum(bytes32 logId, uint32 stepNum) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = logId;

    StoreSwitch.setField(_tableId, _keyTuple, 7, abi.encodePacked((stepNum)));
  }

  /** Set stepNum (using the specified store) */
  function setStepNum(IStore _store, bytes32 logId, uint32 stepNum) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = logId;

    _store.setField(_tableId, _keyTuple, 7, abi.encodePacked((stepNum)));
  }

  /** Get startTime */
  function getStartTime(bytes32 logId) internal view returns (uint256 startTime) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = logId;

    bytes memory _blob = StoreSwitch.getField(_tableId, _keyTuple, 8);
    return (uint256(Bytes.slice32(_blob, 0)));
  }

  /** Get startTime (using the specified store) */
  function getStartTime(IStore _store, bytes32 logId) internal view returns (uint256 startTime) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = logId;

    bytes memory _blob = _store.getField(_tableId, _keyTuple, 8);
    return (uint256(Bytes.slice32(_blob, 0)));
  }

  /** Set startTime */
  function setStartTime(bytes32 logId, uint256 startTime) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = logId;

    StoreSwitch.setField(_tableId, _keyTuple, 8, abi.encodePacked((startTime)));
  }

  /** Set startTime (using the specified store) */
  function setStartTime(IStore _store, bytes32 logId, uint256 startTime) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = logId;

    _store.setField(_tableId, _keyTuple, 8, abi.encodePacked((startTime)));
  }

  /** Get requestRandBlock */
  function getRequestRandBlock(bytes32 logId) internal view returns (uint256 requestRandBlock) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = logId;

    bytes memory _blob = StoreSwitch.getField(_tableId, _keyTuple, 9);
    return (uint256(Bytes.slice32(_blob, 0)));
  }

  /** Get requestRandBlock (using the specified store) */
  function getRequestRandBlock(IStore _store, bytes32 logId) internal view returns (uint256 requestRandBlock) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = logId;

    bytes memory _blob = _store.getField(_tableId, _keyTuple, 9);
    return (uint256(Bytes.slice32(_blob, 0)));
  }

  /** Set requestRandBlock */
  function setRequestRandBlock(bytes32 logId, uint256 requestRandBlock) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = logId;

    StoreSwitch.setField(_tableId, _keyTuple, 9, abi.encodePacked((requestRandBlock)));
  }

  /** Set requestRandBlock (using the specified store) */
  function setRequestRandBlock(IStore _store, bytes32 logId, uint256 requestRandBlock) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = logId;

    _store.setField(_tableId, _keyTuple, 9, abi.encodePacked((requestRandBlock)));
  }

  /** Get randomSeed */
  function getRandomSeed(bytes32 logId) internal view returns (uint256 randomSeed) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = logId;

    bytes memory _blob = StoreSwitch.getField(_tableId, _keyTuple, 10);
    return (uint256(Bytes.slice32(_blob, 0)));
  }

  /** Get randomSeed (using the specified store) */
  function getRandomSeed(IStore _store, bytes32 logId) internal view returns (uint256 randomSeed) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = logId;

    bytes memory _blob = _store.getField(_tableId, _keyTuple, 10);
    return (uint256(Bytes.slice32(_blob, 0)));
  }

  /** Set randomSeed */
  function setRandomSeed(bytes32 logId, uint256 randomSeed) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = logId;

    StoreSwitch.setField(_tableId, _keyTuple, 10, abi.encodePacked((randomSeed)));
  }

  /** Set randomSeed (using the specified store) */
  function setRandomSeed(IStore _store, bytes32 logId, uint256 randomSeed) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = logId;

    _store.setField(_tableId, _keyTuple, 10, abi.encodePacked((randomSeed)));
  }

  /** Get endTime */
  function getEndTime(bytes32 logId) internal view returns (uint256 endTime) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = logId;

    bytes memory _blob = StoreSwitch.getField(_tableId, _keyTuple, 11);
    return (uint256(Bytes.slice32(_blob, 0)));
  }

  /** Get endTime (using the specified store) */
  function getEndTime(IStore _store, bytes32 logId) internal view returns (uint256 endTime) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = logId;

    bytes memory _blob = _store.getField(_tableId, _keyTuple, 11);
    return (uint256(Bytes.slice32(_blob, 0)));
  }

  /** Set endTime */
  function setEndTime(bytes32 logId, uint256 endTime) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = logId;

    StoreSwitch.setField(_tableId, _keyTuple, 11, abi.encodePacked((endTime)));
  }

  /** Set endTime (using the specified store) */
  function setEndTime(IStore _store, bytes32 logId, uint256 endTime) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = logId;

    _store.setField(_tableId, _keyTuple, 11, abi.encodePacked((endTime)));
  }

  /** Get lastUpdateTime */
  function getLastUpdateTime(bytes32 logId) internal view returns (uint256 lastUpdateTime) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = logId;

    bytes memory _blob = StoreSwitch.getField(_tableId, _keyTuple, 12);
    return (uint256(Bytes.slice32(_blob, 0)));
  }

  /** Get lastUpdateTime (using the specified store) */
  function getLastUpdateTime(IStore _store, bytes32 logId) internal view returns (uint256 lastUpdateTime) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = logId;

    bytes memory _blob = _store.getField(_tableId, _keyTuple, 12);
    return (uint256(Bytes.slice32(_blob, 0)));
  }

  /** Set lastUpdateTime */
  function setLastUpdateTime(bytes32 logId, uint256 lastUpdateTime) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = logId;

    StoreSwitch.setField(_tableId, _keyTuple, 12, abi.encodePacked((lastUpdateTime)));
  }

  /** Set lastUpdateTime (using the specified store) */
  function setLastUpdateTime(IStore _store, bytes32 logId, uint256 lastUpdateTime) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = logId;

    _store.setField(_tableId, _keyTuple, 12, abi.encodePacked((lastUpdateTime)));
  }

  /** Get status */
  function getStatus(bytes32 logId) internal view returns (uint8 status) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = logId;

    bytes memory _blob = StoreSwitch.getField(_tableId, _keyTuple, 13);
    return (uint8(Bytes.slice1(_blob, 0)));
  }

  /** Get status (using the specified store) */
  function getStatus(IStore _store, bytes32 logId) internal view returns (uint8 status) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = logId;

    bytes memory _blob = _store.getField(_tableId, _keyTuple, 13);
    return (uint8(Bytes.slice1(_blob, 0)));
  }

  /** Set status */
  function setStatus(bytes32 logId, uint8 status) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = logId;

    StoreSwitch.setField(_tableId, _keyTuple, 13, abi.encodePacked((status)));
  }

  /** Set status (using the specified store) */
  function setStatus(IStore _store, bytes32 logId, uint8 status) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = logId;

    _store.setField(_tableId, _keyTuple, 13, abi.encodePacked((status)));
  }

  /** Get rewardCoins */
  function getRewardCoins(bytes32 logId) internal view returns (uint256 rewardCoins) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = logId;

    bytes memory _blob = StoreSwitch.getField(_tableId, _keyTuple, 14);
    return (uint256(Bytes.slice32(_blob, 0)));
  }

  /** Get rewardCoins (using the specified store) */
  function getRewardCoins(IStore _store, bytes32 logId) internal view returns (uint256 rewardCoins) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = logId;

    bytes memory _blob = _store.getField(_tableId, _keyTuple, 14);
    return (uint256(Bytes.slice32(_blob, 0)));
  }

  /** Set rewardCoins */
  function setRewardCoins(bytes32 logId, uint256 rewardCoins) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = logId;

    StoreSwitch.setField(_tableId, _keyTuple, 14, abi.encodePacked((rewardCoins)));
  }

  /** Set rewardCoins (using the specified store) */
  function setRewardCoins(IStore _store, bytes32 logId, uint256 rewardCoins) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = logId;

    _store.setField(_tableId, _keyTuple, 14, abi.encodePacked((rewardCoins)));
  }

  /** Get rewardCatExp */
  function getRewardCatExp(bytes32 logId) internal view returns (uint32 rewardCatExp) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = logId;

    bytes memory _blob = StoreSwitch.getField(_tableId, _keyTuple, 15);
    return (uint32(Bytes.slice4(_blob, 0)));
  }

  /** Get rewardCatExp (using the specified store) */
  function getRewardCatExp(IStore _store, bytes32 logId) internal view returns (uint32 rewardCatExp) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = logId;

    bytes memory _blob = _store.getField(_tableId, _keyTuple, 15);
    return (uint32(Bytes.slice4(_blob, 0)));
  }

  /** Set rewardCatExp */
  function setRewardCatExp(bytes32 logId, uint32 rewardCatExp) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = logId;

    StoreSwitch.setField(_tableId, _keyTuple, 15, abi.encodePacked((rewardCatExp)));
  }

  /** Set rewardCatExp (using the specified store) */
  function setRewardCatExp(IStore _store, bytes32 logId, uint32 rewardCatExp) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = logId;

    _store.setField(_tableId, _keyTuple, 15, abi.encodePacked((rewardCatExp)));
  }

  /** Get rewardUserExp */
  function getRewardUserExp(bytes32 logId) internal view returns (uint32 rewardUserExp) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = logId;

    bytes memory _blob = StoreSwitch.getField(_tableId, _keyTuple, 16);
    return (uint32(Bytes.slice4(_blob, 0)));
  }

  /** Get rewardUserExp (using the specified store) */
  function getRewardUserExp(IStore _store, bytes32 logId) internal view returns (uint32 rewardUserExp) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = logId;

    bytes memory _blob = _store.getField(_tableId, _keyTuple, 16);
    return (uint32(Bytes.slice4(_blob, 0)));
  }

  /** Set rewardUserExp */
  function setRewardUserExp(bytes32 logId, uint32 rewardUserExp) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = logId;

    StoreSwitch.setField(_tableId, _keyTuple, 16, abi.encodePacked((rewardUserExp)));
  }

  /** Set rewardUserExp (using the specified store) */
  function setRewardUserExp(IStore _store, bytes32 logId, uint32 rewardUserExp) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = logId;

    _store.setField(_tableId, _keyTuple, 16, abi.encodePacked((rewardUserExp)));
  }

  /** Get rewardItems */
  function getRewardItems(bytes32 logId) internal view returns (bytes32[] memory rewardItems) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = logId;

    bytes memory _blob = StoreSwitch.getField(_tableId, _keyTuple, 17);
    return (SliceLib.getSubslice(_blob, 0, _blob.length).decodeArray_bytes32());
  }

  /** Get rewardItems (using the specified store) */
  function getRewardItems(IStore _store, bytes32 logId) internal view returns (bytes32[] memory rewardItems) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = logId;

    bytes memory _blob = _store.getField(_tableId, _keyTuple, 17);
    return (SliceLib.getSubslice(_blob, 0, _blob.length).decodeArray_bytes32());
  }

  /** Set rewardItems */
  function setRewardItems(bytes32 logId, bytes32[] memory rewardItems) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = logId;

    StoreSwitch.setField(_tableId, _keyTuple, 17, EncodeArray.encode((rewardItems)));
  }

  /** Set rewardItems (using the specified store) */
  function setRewardItems(IStore _store, bytes32 logId, bytes32[] memory rewardItems) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = logId;

    _store.setField(_tableId, _keyTuple, 17, EncodeArray.encode((rewardItems)));
  }

  /** Get the length of rewardItems */
  function lengthRewardItems(bytes32 logId) internal view returns (uint256) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = logId;

    uint256 _byteLength = StoreSwitch.getFieldLength(_tableId, _keyTuple, 17, getSchema());
    return _byteLength / 32;
  }

  /** Get the length of rewardItems (using the specified store) */
  function lengthRewardItems(IStore _store, bytes32 logId) internal view returns (uint256) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = logId;

    uint256 _byteLength = _store.getFieldLength(_tableId, _keyTuple, 17, getSchema());
    return _byteLength / 32;
  }

  /** Get an item of rewardItems (unchecked, returns invalid data if index overflows) */
  function getItemRewardItems(bytes32 logId, uint256 _index) internal view returns (bytes32) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = logId;

    bytes memory _blob = StoreSwitch.getFieldSlice(
      _tableId,
      _keyTuple,
      17,
      getSchema(),
      _index * 32,
      (_index + 1) * 32
    );
    return (Bytes.slice32(_blob, 0));
  }

  /** Get an item of rewardItems (using the specified store) (unchecked, returns invalid data if index overflows) */
  function getItemRewardItems(IStore _store, bytes32 logId, uint256 _index) internal view returns (bytes32) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = logId;

    bytes memory _blob = _store.getFieldSlice(_tableId, _keyTuple, 17, getSchema(), _index * 32, (_index + 1) * 32);
    return (Bytes.slice32(_blob, 0));
  }

  /** Push an element to rewardItems */
  function pushRewardItems(bytes32 logId, bytes32 _element) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = logId;

    StoreSwitch.pushToField(_tableId, _keyTuple, 17, abi.encodePacked((_element)));
  }

  /** Push an element to rewardItems (using the specified store) */
  function pushRewardItems(IStore _store, bytes32 logId, bytes32 _element) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = logId;

    _store.pushToField(_tableId, _keyTuple, 17, abi.encodePacked((_element)));
  }

  /** Pop an element from rewardItems */
  function popRewardItems(bytes32 logId) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = logId;

    StoreSwitch.popFromField(_tableId, _keyTuple, 17, 32);
  }

  /** Pop an element from rewardItems (using the specified store) */
  function popRewardItems(IStore _store, bytes32 logId) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = logId;

    _store.popFromField(_tableId, _keyTuple, 17, 32);
  }

  /** Update an element of rewardItems at `_index` */
  function updateRewardItems(bytes32 logId, uint256 _index, bytes32 _element) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = logId;

    StoreSwitch.updateInField(_tableId, _keyTuple, 17, _index * 32, abi.encodePacked((_element)));
  }

  /** Update an element of rewardItems (using the specified store) at `_index` */
  function updateRewardItems(IStore _store, bytes32 logId, uint256 _index, bytes32 _element) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = logId;

    _store.updateInField(_tableId, _keyTuple, 17, _index * 32, abi.encodePacked((_element)));
  }

  /** Get the full data */
  function get(bytes32 logId) internal view returns (HobbyLogData memory _table) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = logId;

    bytes memory _blob = StoreSwitch.getRecord(_tableId, _keyTuple, getSchema());
    return decode(_blob);
  }

  /** Get the full data (using the specified store) */
  function get(IStore _store, bytes32 logId) internal view returns (HobbyLogData memory _table) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = logId;

    bytes memory _blob = _store.getRecord(_tableId, _keyTuple, getSchema());
    return decode(_blob);
  }

  /** Set the full data using individual values */
  function set(
    bytes32 logId,
    bytes32 catId,
    bytes32 hobbyId,
    uint8 tier,
    bytes32 tagId,
    uint32 tierTagIndex,
    uint32 dropRate,
    uint256 specialEffect,
    uint32 stepNum,
    uint256 startTime,
    uint256 requestRandBlock,
    uint256 randomSeed,
    uint256 endTime,
    uint256 lastUpdateTime,
    uint8 status,
    uint256 rewardCoins,
    uint32 rewardCatExp,
    uint32 rewardUserExp,
    bytes32[] memory rewardItems
  ) internal {
    bytes memory _data = encode(
      catId,
      hobbyId,
      tier,
      tagId,
      tierTagIndex,
      dropRate,
      specialEffect,
      stepNum,
      startTime,
      requestRandBlock,
      randomSeed,
      endTime,
      lastUpdateTime,
      status,
      rewardCoins,
      rewardCatExp,
      rewardUserExp,
      rewardItems
    );

    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = logId;

    StoreSwitch.setRecord(_tableId, _keyTuple, _data);
  }

  /** Set the full data using individual values (using the specified store) */
  function set(
    IStore _store,
    bytes32 logId,
    bytes32 catId,
    bytes32 hobbyId,
    uint8 tier,
    bytes32 tagId,
    uint32 tierTagIndex,
    uint32 dropRate,
    uint256 specialEffect,
    uint32 stepNum,
    uint256 startTime,
    uint256 requestRandBlock,
    uint256 randomSeed,
    uint256 endTime,
    uint256 lastUpdateTime,
    uint8 status,
    uint256 rewardCoins,
    uint32 rewardCatExp,
    uint32 rewardUserExp,
    bytes32[] memory rewardItems
  ) internal {
    bytes memory _data = encode(
      catId,
      hobbyId,
      tier,
      tagId,
      tierTagIndex,
      dropRate,
      specialEffect,
      stepNum,
      startTime,
      requestRandBlock,
      randomSeed,
      endTime,
      lastUpdateTime,
      status,
      rewardCoins,
      rewardCatExp,
      rewardUserExp,
      rewardItems
    );

    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = logId;

    _store.setRecord(_tableId, _keyTuple, _data);
  }

  /** Set the full data using the data struct */
  function set(bytes32 logId, HobbyLogData memory _table) internal {
    set(
      logId,
      _table.catId,
      _table.hobbyId,
      _table.tier,
      _table.tagId,
      _table.tierTagIndex,
      _table.dropRate,
      _table.specialEffect,
      _table.stepNum,
      _table.startTime,
      _table.requestRandBlock,
      _table.randomSeed,
      _table.endTime,
      _table.lastUpdateTime,
      _table.status,
      _table.rewardCoins,
      _table.rewardCatExp,
      _table.rewardUserExp,
      _table.rewardItems
    );
  }

  /** Set the full data using the data struct (using the specified store) */
  function set(IStore _store, bytes32 logId, HobbyLogData memory _table) internal {
    set(
      _store,
      logId,
      _table.catId,
      _table.hobbyId,
      _table.tier,
      _table.tagId,
      _table.tierTagIndex,
      _table.dropRate,
      _table.specialEffect,
      _table.stepNum,
      _table.startTime,
      _table.requestRandBlock,
      _table.randomSeed,
      _table.endTime,
      _table.lastUpdateTime,
      _table.status,
      _table.rewardCoins,
      _table.rewardCatExp,
      _table.rewardUserExp,
      _table.rewardItems
    );
  }

  /** Decode the tightly packed blob using this table's schema */
  function decode(bytes memory _blob) internal view returns (HobbyLogData memory _table) {
    // 342 is the total byte length of static data
    PackedCounter _encodedLengths = PackedCounter.wrap(Bytes.slice32(_blob, 342));

    _table.catId = (Bytes.slice32(_blob, 0));

    _table.hobbyId = (Bytes.slice32(_blob, 32));

    _table.tier = (uint8(Bytes.slice1(_blob, 64)));

    _table.tagId = (Bytes.slice32(_blob, 65));

    _table.tierTagIndex = (uint32(Bytes.slice4(_blob, 97)));

    _table.dropRate = (uint32(Bytes.slice4(_blob, 101)));

    _table.specialEffect = (uint256(Bytes.slice32(_blob, 105)));

    _table.stepNum = (uint32(Bytes.slice4(_blob, 137)));

    _table.startTime = (uint256(Bytes.slice32(_blob, 141)));

    _table.requestRandBlock = (uint256(Bytes.slice32(_blob, 173)));

    _table.randomSeed = (uint256(Bytes.slice32(_blob, 205)));

    _table.endTime = (uint256(Bytes.slice32(_blob, 237)));

    _table.lastUpdateTime = (uint256(Bytes.slice32(_blob, 269)));

    _table.status = (uint8(Bytes.slice1(_blob, 301)));

    _table.rewardCoins = (uint256(Bytes.slice32(_blob, 302)));

    _table.rewardCatExp = (uint32(Bytes.slice4(_blob, 334)));

    _table.rewardUserExp = (uint32(Bytes.slice4(_blob, 338)));

    // Store trims the blob if dynamic fields are all empty
    if (_blob.length > 342) {
      uint256 _start;
      // skip static data length + dynamic lengths word
      uint256 _end = 374;

      _start = _end;
      _end += _encodedLengths.atIndex(0);
      _table.rewardItems = (SliceLib.getSubslice(_blob, _start, _end).decodeArray_bytes32());
    }
  }

  /** Tightly pack full data using this table's schema */
  function encode(
    bytes32 catId,
    bytes32 hobbyId,
    uint8 tier,
    bytes32 tagId,
    uint32 tierTagIndex,
    uint32 dropRate,
    uint256 specialEffect,
    uint32 stepNum,
    uint256 startTime,
    uint256 requestRandBlock,
    uint256 randomSeed,
    uint256 endTime,
    uint256 lastUpdateTime,
    uint8 status,
    uint256 rewardCoins,
    uint32 rewardCatExp,
    uint32 rewardUserExp,
    bytes32[] memory rewardItems
  ) internal view returns (bytes memory) {
    uint40[] memory _counters = new uint40[](1);
    _counters[0] = uint40(rewardItems.length * 32);
    PackedCounter _encodedLengths = PackedCounterLib.pack(_counters);

    return
      abi.encodePacked(
        catId,
        hobbyId,
        tier,
        tagId,
        tierTagIndex,
        dropRate,
        specialEffect,
        stepNum,
        startTime,
        requestRandBlock,
        randomSeed,
        endTime,
        lastUpdateTime,
        status,
        rewardCoins,
        rewardCatExp,
        rewardUserExp,
        _encodedLengths.unwrap(),
        EncodeArray.encode((rewardItems))
      );
  }

  /** Encode keys as a bytes32 array using this table's schema */
  function encodeKeyTuple(bytes32 logId) internal pure returns (bytes32[] memory _keyTuple) {
    _keyTuple = new bytes32[](1);
    _keyTuple[0] = logId;
  }

  /* Delete all data for given keys */
  function deleteRecord(bytes32 logId) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = logId;

    StoreSwitch.deleteRecord(_tableId, _keyTuple);
  }

  /* Delete all data for given keys (using the specified store) */
  function deleteRecord(IStore _store, bytes32 logId) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = logId;

    _store.deleteRecord(_tableId, _keyTuple);
  }
}
