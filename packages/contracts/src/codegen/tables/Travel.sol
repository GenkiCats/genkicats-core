// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

/* Autogenerated file. Do not edit manually. */

// Import schema type
import { SchemaType } from "@latticexyz/schema-type/src/solidity/SchemaType.sol";

// Import store internals
import { IStore } from "@latticexyz/store/src/IStore.sol";
import { StoreSwitch } from "@latticexyz/store/src/StoreSwitch.sol";
import { StoreCore } from "@latticexyz/store/src/StoreCore.sol";
import { Bytes } from "@latticexyz/store/src/Bytes.sol";
import { Memory } from "@latticexyz/store/src/Memory.sol";
import { SliceLib } from "@latticexyz/store/src/Slice.sol";
import { EncodeArray } from "@latticexyz/store/src/tightcoder/EncodeArray.sol";
import { Schema, SchemaLib } from "@latticexyz/store/src/Schema.sol";
import { PackedCounter, PackedCounterLib } from "@latticexyz/store/src/PackedCounter.sol";

bytes32 constant _tableId = bytes32(abi.encodePacked(bytes16(""), bytes16("Travel")));
bytes32 constant TravelTableId = _tableId;

struct TravelData {
  uint256 travelId;
  uint256 spotId;
  uint8 travelStatus;
  uint8 travelType;
  bytes32 rewardItemsHash;
  uint32 hunger;
  uint32 fun;
  uint256 originPhotoId;
  uint32 startTime;
  uint32 endTime;
  uint32 startWaitingDuration;
  uint256 foodId;
  bytes32 backpackItemsHash;
  uint256 randSeed;
  uint256[] candidateCats;
  uint256[] catIds;
}

library Travel {
  /** Get the table's schema */
  function getSchema() internal pure returns (Schema) {
    SchemaType[] memory _schema = new SchemaType[](16);
    _schema[0] = SchemaType.UINT256;
    _schema[1] = SchemaType.UINT256;
    _schema[2] = SchemaType.UINT8;
    _schema[3] = SchemaType.UINT8;
    _schema[4] = SchemaType.BYTES32;
    _schema[5] = SchemaType.UINT32;
    _schema[6] = SchemaType.UINT32;
    _schema[7] = SchemaType.UINT256;
    _schema[8] = SchemaType.UINT32;
    _schema[9] = SchemaType.UINT32;
    _schema[10] = SchemaType.UINT32;
    _schema[11] = SchemaType.UINT256;
    _schema[12] = SchemaType.BYTES32;
    _schema[13] = SchemaType.UINT256;
    _schema[14] = SchemaType.UINT256_ARRAY;
    _schema[15] = SchemaType.UINT256_ARRAY;

    return SchemaLib.encode(_schema);
  }

  function getKeySchema() internal pure returns (Schema) {
    SchemaType[] memory _schema = new SchemaType[](1);
    _schema[0] = SchemaType.BYTES32;

    return SchemaLib.encode(_schema);
  }

  /** Get the table's metadata */
  function getMetadata() internal pure returns (string memory, string[] memory) {
    string[] memory _fieldNames = new string[](16);
    _fieldNames[0] = "travelId";
    _fieldNames[1] = "spotId";
    _fieldNames[2] = "travelStatus";
    _fieldNames[3] = "travelType";
    _fieldNames[4] = "rewardItemsHash";
    _fieldNames[5] = "hunger";
    _fieldNames[6] = "fun";
    _fieldNames[7] = "originPhotoId";
    _fieldNames[8] = "startTime";
    _fieldNames[9] = "endTime";
    _fieldNames[10] = "startWaitingDuration";
    _fieldNames[11] = "foodId";
    _fieldNames[12] = "backpackItemsHash";
    _fieldNames[13] = "randSeed";
    _fieldNames[14] = "candidateCats";
    _fieldNames[15] = "catIds";
    return ("Travel", _fieldNames);
  }

  /** Register the table's schema */
  function registerSchema() internal {
    StoreSwitch.registerSchema(_tableId, getSchema(), getKeySchema());
  }

  /** Register the table's schema (using the specified store) */
  function registerSchema(IStore _store) internal {
    _store.registerSchema(_tableId, getSchema(), getKeySchema());
  }

  /** Set the table's metadata */
  function setMetadata() internal {
    (string memory _tableName, string[] memory _fieldNames) = getMetadata();
    StoreSwitch.setMetadata(_tableId, _tableName, _fieldNames);
  }

  /** Set the table's metadata (using the specified store) */
  function setMetadata(IStore _store) internal {
    (string memory _tableName, string[] memory _fieldNames) = getMetadata();
    _store.setMetadata(_tableId, _tableName, _fieldNames);
  }

  /** Get travelId */
  function getTravelId(bytes32 userId) internal view returns (uint256 travelId) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = userId;

    bytes memory _blob = StoreSwitch.getField(_tableId, _keyTuple, 0);
    return (uint256(Bytes.slice32(_blob, 0)));
  }

  /** Get travelId (using the specified store) */
  function getTravelId(IStore _store, bytes32 userId) internal view returns (uint256 travelId) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = userId;

    bytes memory _blob = _store.getField(_tableId, _keyTuple, 0);
    return (uint256(Bytes.slice32(_blob, 0)));
  }

  /** Set travelId */
  function setTravelId(bytes32 userId, uint256 travelId) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = userId;

    StoreSwitch.setField(_tableId, _keyTuple, 0, abi.encodePacked((travelId)));
  }

  /** Set travelId (using the specified store) */
  function setTravelId(IStore _store, bytes32 userId, uint256 travelId) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = userId;

    _store.setField(_tableId, _keyTuple, 0, abi.encodePacked((travelId)));
  }

  /** Get spotId */
  function getSpotId(bytes32 userId) internal view returns (uint256 spotId) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = userId;

    bytes memory _blob = StoreSwitch.getField(_tableId, _keyTuple, 1);
    return (uint256(Bytes.slice32(_blob, 0)));
  }

  /** Get spotId (using the specified store) */
  function getSpotId(IStore _store, bytes32 userId) internal view returns (uint256 spotId) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = userId;

    bytes memory _blob = _store.getField(_tableId, _keyTuple, 1);
    return (uint256(Bytes.slice32(_blob, 0)));
  }

  /** Set spotId */
  function setSpotId(bytes32 userId, uint256 spotId) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = userId;

    StoreSwitch.setField(_tableId, _keyTuple, 1, abi.encodePacked((spotId)));
  }

  /** Set spotId (using the specified store) */
  function setSpotId(IStore _store, bytes32 userId, uint256 spotId) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = userId;

    _store.setField(_tableId, _keyTuple, 1, abi.encodePacked((spotId)));
  }

  /** Get travelStatus */
  function getTravelStatus(bytes32 userId) internal view returns (uint8 travelStatus) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = userId;

    bytes memory _blob = StoreSwitch.getField(_tableId, _keyTuple, 2);
    return (uint8(Bytes.slice1(_blob, 0)));
  }

  /** Get travelStatus (using the specified store) */
  function getTravelStatus(IStore _store, bytes32 userId) internal view returns (uint8 travelStatus) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = userId;

    bytes memory _blob = _store.getField(_tableId, _keyTuple, 2);
    return (uint8(Bytes.slice1(_blob, 0)));
  }

  /** Set travelStatus */
  function setTravelStatus(bytes32 userId, uint8 travelStatus) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = userId;

    StoreSwitch.setField(_tableId, _keyTuple, 2, abi.encodePacked((travelStatus)));
  }

  /** Set travelStatus (using the specified store) */
  function setTravelStatus(IStore _store, bytes32 userId, uint8 travelStatus) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = userId;

    _store.setField(_tableId, _keyTuple, 2, abi.encodePacked((travelStatus)));
  }

  /** Get travelType */
  function getTravelType(bytes32 userId) internal view returns (uint8 travelType) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = userId;

    bytes memory _blob = StoreSwitch.getField(_tableId, _keyTuple, 3);
    return (uint8(Bytes.slice1(_blob, 0)));
  }

  /** Get travelType (using the specified store) */
  function getTravelType(IStore _store, bytes32 userId) internal view returns (uint8 travelType) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = userId;

    bytes memory _blob = _store.getField(_tableId, _keyTuple, 3);
    return (uint8(Bytes.slice1(_blob, 0)));
  }

  /** Set travelType */
  function setTravelType(bytes32 userId, uint8 travelType) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = userId;

    StoreSwitch.setField(_tableId, _keyTuple, 3, abi.encodePacked((travelType)));
  }

  /** Set travelType (using the specified store) */
  function setTravelType(IStore _store, bytes32 userId, uint8 travelType) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = userId;

    _store.setField(_tableId, _keyTuple, 3, abi.encodePacked((travelType)));
  }

  /** Get rewardItemsHash */
  function getRewardItemsHash(bytes32 userId) internal view returns (bytes32 rewardItemsHash) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = userId;

    bytes memory _blob = StoreSwitch.getField(_tableId, _keyTuple, 4);
    return (Bytes.slice32(_blob, 0));
  }

  /** Get rewardItemsHash (using the specified store) */
  function getRewardItemsHash(IStore _store, bytes32 userId) internal view returns (bytes32 rewardItemsHash) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = userId;

    bytes memory _blob = _store.getField(_tableId, _keyTuple, 4);
    return (Bytes.slice32(_blob, 0));
  }

  /** Set rewardItemsHash */
  function setRewardItemsHash(bytes32 userId, bytes32 rewardItemsHash) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = userId;

    StoreSwitch.setField(_tableId, _keyTuple, 4, abi.encodePacked((rewardItemsHash)));
  }

  /** Set rewardItemsHash (using the specified store) */
  function setRewardItemsHash(IStore _store, bytes32 userId, bytes32 rewardItemsHash) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = userId;

    _store.setField(_tableId, _keyTuple, 4, abi.encodePacked((rewardItemsHash)));
  }

  /** Get hunger */
  function getHunger(bytes32 userId) internal view returns (uint32 hunger) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = userId;

    bytes memory _blob = StoreSwitch.getField(_tableId, _keyTuple, 5);
    return (uint32(Bytes.slice4(_blob, 0)));
  }

  /** Get hunger (using the specified store) */
  function getHunger(IStore _store, bytes32 userId) internal view returns (uint32 hunger) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = userId;

    bytes memory _blob = _store.getField(_tableId, _keyTuple, 5);
    return (uint32(Bytes.slice4(_blob, 0)));
  }

  /** Set hunger */
  function setHunger(bytes32 userId, uint32 hunger) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = userId;

    StoreSwitch.setField(_tableId, _keyTuple, 5, abi.encodePacked((hunger)));
  }

  /** Set hunger (using the specified store) */
  function setHunger(IStore _store, bytes32 userId, uint32 hunger) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = userId;

    _store.setField(_tableId, _keyTuple, 5, abi.encodePacked((hunger)));
  }

  /** Get fun */
  function getFun(bytes32 userId) internal view returns (uint32 fun) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = userId;

    bytes memory _blob = StoreSwitch.getField(_tableId, _keyTuple, 6);
    return (uint32(Bytes.slice4(_blob, 0)));
  }

  /** Get fun (using the specified store) */
  function getFun(IStore _store, bytes32 userId) internal view returns (uint32 fun) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = userId;

    bytes memory _blob = _store.getField(_tableId, _keyTuple, 6);
    return (uint32(Bytes.slice4(_blob, 0)));
  }

  /** Set fun */
  function setFun(bytes32 userId, uint32 fun) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = userId;

    StoreSwitch.setField(_tableId, _keyTuple, 6, abi.encodePacked((fun)));
  }

  /** Set fun (using the specified store) */
  function setFun(IStore _store, bytes32 userId, uint32 fun) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = userId;

    _store.setField(_tableId, _keyTuple, 6, abi.encodePacked((fun)));
  }

  /** Get originPhotoId */
  function getOriginPhotoId(bytes32 userId) internal view returns (uint256 originPhotoId) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = userId;

    bytes memory _blob = StoreSwitch.getField(_tableId, _keyTuple, 7);
    return (uint256(Bytes.slice32(_blob, 0)));
  }

  /** Get originPhotoId (using the specified store) */
  function getOriginPhotoId(IStore _store, bytes32 userId) internal view returns (uint256 originPhotoId) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = userId;

    bytes memory _blob = _store.getField(_tableId, _keyTuple, 7);
    return (uint256(Bytes.slice32(_blob, 0)));
  }

  /** Set originPhotoId */
  function setOriginPhotoId(bytes32 userId, uint256 originPhotoId) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = userId;

    StoreSwitch.setField(_tableId, _keyTuple, 7, abi.encodePacked((originPhotoId)));
  }

  /** Set originPhotoId (using the specified store) */
  function setOriginPhotoId(IStore _store, bytes32 userId, uint256 originPhotoId) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = userId;

    _store.setField(_tableId, _keyTuple, 7, abi.encodePacked((originPhotoId)));
  }

  /** Get startTime */
  function getStartTime(bytes32 userId) internal view returns (uint32 startTime) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = userId;

    bytes memory _blob = StoreSwitch.getField(_tableId, _keyTuple, 8);
    return (uint32(Bytes.slice4(_blob, 0)));
  }

  /** Get startTime (using the specified store) */
  function getStartTime(IStore _store, bytes32 userId) internal view returns (uint32 startTime) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = userId;

    bytes memory _blob = _store.getField(_tableId, _keyTuple, 8);
    return (uint32(Bytes.slice4(_blob, 0)));
  }

  /** Set startTime */
  function setStartTime(bytes32 userId, uint32 startTime) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = userId;

    StoreSwitch.setField(_tableId, _keyTuple, 8, abi.encodePacked((startTime)));
  }

  /** Set startTime (using the specified store) */
  function setStartTime(IStore _store, bytes32 userId, uint32 startTime) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = userId;

    _store.setField(_tableId, _keyTuple, 8, abi.encodePacked((startTime)));
  }

  /** Get endTime */
  function getEndTime(bytes32 userId) internal view returns (uint32 endTime) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = userId;

    bytes memory _blob = StoreSwitch.getField(_tableId, _keyTuple, 9);
    return (uint32(Bytes.slice4(_blob, 0)));
  }

  /** Get endTime (using the specified store) */
  function getEndTime(IStore _store, bytes32 userId) internal view returns (uint32 endTime) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = userId;

    bytes memory _blob = _store.getField(_tableId, _keyTuple, 9);
    return (uint32(Bytes.slice4(_blob, 0)));
  }

  /** Set endTime */
  function setEndTime(bytes32 userId, uint32 endTime) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = userId;

    StoreSwitch.setField(_tableId, _keyTuple, 9, abi.encodePacked((endTime)));
  }

  /** Set endTime (using the specified store) */
  function setEndTime(IStore _store, bytes32 userId, uint32 endTime) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = userId;

    _store.setField(_tableId, _keyTuple, 9, abi.encodePacked((endTime)));
  }

  /** Get startWaitingDuration */
  function getStartWaitingDuration(bytes32 userId) internal view returns (uint32 startWaitingDuration) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = userId;

    bytes memory _blob = StoreSwitch.getField(_tableId, _keyTuple, 10);
    return (uint32(Bytes.slice4(_blob, 0)));
  }

  /** Get startWaitingDuration (using the specified store) */
  function getStartWaitingDuration(IStore _store, bytes32 userId) internal view returns (uint32 startWaitingDuration) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = userId;

    bytes memory _blob = _store.getField(_tableId, _keyTuple, 10);
    return (uint32(Bytes.slice4(_blob, 0)));
  }

  /** Set startWaitingDuration */
  function setStartWaitingDuration(bytes32 userId, uint32 startWaitingDuration) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = userId;

    StoreSwitch.setField(_tableId, _keyTuple, 10, abi.encodePacked((startWaitingDuration)));
  }

  /** Set startWaitingDuration (using the specified store) */
  function setStartWaitingDuration(IStore _store, bytes32 userId, uint32 startWaitingDuration) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = userId;

    _store.setField(_tableId, _keyTuple, 10, abi.encodePacked((startWaitingDuration)));
  }

  /** Get foodId */
  function getFoodId(bytes32 userId) internal view returns (uint256 foodId) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = userId;

    bytes memory _blob = StoreSwitch.getField(_tableId, _keyTuple, 11);
    return (uint256(Bytes.slice32(_blob, 0)));
  }

  /** Get foodId (using the specified store) */
  function getFoodId(IStore _store, bytes32 userId) internal view returns (uint256 foodId) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = userId;

    bytes memory _blob = _store.getField(_tableId, _keyTuple, 11);
    return (uint256(Bytes.slice32(_blob, 0)));
  }

  /** Set foodId */
  function setFoodId(bytes32 userId, uint256 foodId) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = userId;

    StoreSwitch.setField(_tableId, _keyTuple, 11, abi.encodePacked((foodId)));
  }

  /** Set foodId (using the specified store) */
  function setFoodId(IStore _store, bytes32 userId, uint256 foodId) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = userId;

    _store.setField(_tableId, _keyTuple, 11, abi.encodePacked((foodId)));
  }

  /** Get backpackItemsHash */
  function getBackpackItemsHash(bytes32 userId) internal view returns (bytes32 backpackItemsHash) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = userId;

    bytes memory _blob = StoreSwitch.getField(_tableId, _keyTuple, 12);
    return (Bytes.slice32(_blob, 0));
  }

  /** Get backpackItemsHash (using the specified store) */
  function getBackpackItemsHash(IStore _store, bytes32 userId) internal view returns (bytes32 backpackItemsHash) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = userId;

    bytes memory _blob = _store.getField(_tableId, _keyTuple, 12);
    return (Bytes.slice32(_blob, 0));
  }

  /** Set backpackItemsHash */
  function setBackpackItemsHash(bytes32 userId, bytes32 backpackItemsHash) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = userId;

    StoreSwitch.setField(_tableId, _keyTuple, 12, abi.encodePacked((backpackItemsHash)));
  }

  /** Set backpackItemsHash (using the specified store) */
  function setBackpackItemsHash(IStore _store, bytes32 userId, bytes32 backpackItemsHash) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = userId;

    _store.setField(_tableId, _keyTuple, 12, abi.encodePacked((backpackItemsHash)));
  }

  /** Get randSeed */
  function getRandSeed(bytes32 userId) internal view returns (uint256 randSeed) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = userId;

    bytes memory _blob = StoreSwitch.getField(_tableId, _keyTuple, 13);
    return (uint256(Bytes.slice32(_blob, 0)));
  }

  /** Get randSeed (using the specified store) */
  function getRandSeed(IStore _store, bytes32 userId) internal view returns (uint256 randSeed) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = userId;

    bytes memory _blob = _store.getField(_tableId, _keyTuple, 13);
    return (uint256(Bytes.slice32(_blob, 0)));
  }

  /** Set randSeed */
  function setRandSeed(bytes32 userId, uint256 randSeed) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = userId;

    StoreSwitch.setField(_tableId, _keyTuple, 13, abi.encodePacked((randSeed)));
  }

  /** Set randSeed (using the specified store) */
  function setRandSeed(IStore _store, bytes32 userId, uint256 randSeed) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = userId;

    _store.setField(_tableId, _keyTuple, 13, abi.encodePacked((randSeed)));
  }

  /** Get candidateCats */
  function getCandidateCats(bytes32 userId) internal view returns (uint256[] memory candidateCats) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = userId;

    bytes memory _blob = StoreSwitch.getField(_tableId, _keyTuple, 14);
    return (SliceLib.getSubslice(_blob, 0, _blob.length).decodeArray_uint256());
  }

  /** Get candidateCats (using the specified store) */
  function getCandidateCats(IStore _store, bytes32 userId) internal view returns (uint256[] memory candidateCats) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = userId;

    bytes memory _blob = _store.getField(_tableId, _keyTuple, 14);
    return (SliceLib.getSubslice(_blob, 0, _blob.length).decodeArray_uint256());
  }

  /** Set candidateCats */
  function setCandidateCats(bytes32 userId, uint256[] memory candidateCats) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = userId;

    StoreSwitch.setField(_tableId, _keyTuple, 14, EncodeArray.encode((candidateCats)));
  }

  /** Set candidateCats (using the specified store) */
  function setCandidateCats(IStore _store, bytes32 userId, uint256[] memory candidateCats) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = userId;

    _store.setField(_tableId, _keyTuple, 14, EncodeArray.encode((candidateCats)));
  }

  /** Get the length of candidateCats */
  function lengthCandidateCats(bytes32 userId) internal view returns (uint256) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = userId;

    uint256 _byteLength = StoreSwitch.getFieldLength(_tableId, _keyTuple, 14, getSchema());
    return _byteLength / 32;
  }

  /** Get the length of candidateCats (using the specified store) */
  function lengthCandidateCats(IStore _store, bytes32 userId) internal view returns (uint256) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = userId;

    uint256 _byteLength = _store.getFieldLength(_tableId, _keyTuple, 14, getSchema());
    return _byteLength / 32;
  }

  /** Get an item of candidateCats (unchecked, returns invalid data if index overflows) */
  function getItemCandidateCats(bytes32 userId, uint256 _index) internal view returns (uint256) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = userId;

    bytes memory _blob = StoreSwitch.getFieldSlice(
      _tableId,
      _keyTuple,
      14,
      getSchema(),
      _index * 32,
      (_index + 1) * 32
    );
    return (uint256(Bytes.slice32(_blob, 0)));
  }

  /** Get an item of candidateCats (using the specified store) (unchecked, returns invalid data if index overflows) */
  function getItemCandidateCats(IStore _store, bytes32 userId, uint256 _index) internal view returns (uint256) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = userId;

    bytes memory _blob = _store.getFieldSlice(_tableId, _keyTuple, 14, getSchema(), _index * 32, (_index + 1) * 32);
    return (uint256(Bytes.slice32(_blob, 0)));
  }

  /** Push an element to candidateCats */
  function pushCandidateCats(bytes32 userId, uint256 _element) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = userId;

    StoreSwitch.pushToField(_tableId, _keyTuple, 14, abi.encodePacked((_element)));
  }

  /** Push an element to candidateCats (using the specified store) */
  function pushCandidateCats(IStore _store, bytes32 userId, uint256 _element) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = userId;

    _store.pushToField(_tableId, _keyTuple, 14, abi.encodePacked((_element)));
  }

  /** Pop an element from candidateCats */
  function popCandidateCats(bytes32 userId) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = userId;

    StoreSwitch.popFromField(_tableId, _keyTuple, 14, 32);
  }

  /** Pop an element from candidateCats (using the specified store) */
  function popCandidateCats(IStore _store, bytes32 userId) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = userId;

    _store.popFromField(_tableId, _keyTuple, 14, 32);
  }

  /** Update an element of candidateCats at `_index` */
  function updateCandidateCats(bytes32 userId, uint256 _index, uint256 _element) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = userId;

    StoreSwitch.updateInField(_tableId, _keyTuple, 14, _index * 32, abi.encodePacked((_element)));
  }

  /** Update an element of candidateCats (using the specified store) at `_index` */
  function updateCandidateCats(IStore _store, bytes32 userId, uint256 _index, uint256 _element) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = userId;

    _store.updateInField(_tableId, _keyTuple, 14, _index * 32, abi.encodePacked((_element)));
  }

  /** Get catIds */
  function getCatIds(bytes32 userId) internal view returns (uint256[] memory catIds) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = userId;

    bytes memory _blob = StoreSwitch.getField(_tableId, _keyTuple, 15);
    return (SliceLib.getSubslice(_blob, 0, _blob.length).decodeArray_uint256());
  }

  /** Get catIds (using the specified store) */
  function getCatIds(IStore _store, bytes32 userId) internal view returns (uint256[] memory catIds) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = userId;

    bytes memory _blob = _store.getField(_tableId, _keyTuple, 15);
    return (SliceLib.getSubslice(_blob, 0, _blob.length).decodeArray_uint256());
  }

  /** Set catIds */
  function setCatIds(bytes32 userId, uint256[] memory catIds) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = userId;

    StoreSwitch.setField(_tableId, _keyTuple, 15, EncodeArray.encode((catIds)));
  }

  /** Set catIds (using the specified store) */
  function setCatIds(IStore _store, bytes32 userId, uint256[] memory catIds) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = userId;

    _store.setField(_tableId, _keyTuple, 15, EncodeArray.encode((catIds)));
  }

  /** Get the length of catIds */
  function lengthCatIds(bytes32 userId) internal view returns (uint256) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = userId;

    uint256 _byteLength = StoreSwitch.getFieldLength(_tableId, _keyTuple, 15, getSchema());
    return _byteLength / 32;
  }

  /** Get the length of catIds (using the specified store) */
  function lengthCatIds(IStore _store, bytes32 userId) internal view returns (uint256) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = userId;

    uint256 _byteLength = _store.getFieldLength(_tableId, _keyTuple, 15, getSchema());
    return _byteLength / 32;
  }

  /** Get an item of catIds (unchecked, returns invalid data if index overflows) */
  function getItemCatIds(bytes32 userId, uint256 _index) internal view returns (uint256) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = userId;

    bytes memory _blob = StoreSwitch.getFieldSlice(
      _tableId,
      _keyTuple,
      15,
      getSchema(),
      _index * 32,
      (_index + 1) * 32
    );
    return (uint256(Bytes.slice32(_blob, 0)));
  }

  /** Get an item of catIds (using the specified store) (unchecked, returns invalid data if index overflows) */
  function getItemCatIds(IStore _store, bytes32 userId, uint256 _index) internal view returns (uint256) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = userId;

    bytes memory _blob = _store.getFieldSlice(_tableId, _keyTuple, 15, getSchema(), _index * 32, (_index + 1) * 32);
    return (uint256(Bytes.slice32(_blob, 0)));
  }

  /** Push an element to catIds */
  function pushCatIds(bytes32 userId, uint256 _element) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = userId;

    StoreSwitch.pushToField(_tableId, _keyTuple, 15, abi.encodePacked((_element)));
  }

  /** Push an element to catIds (using the specified store) */
  function pushCatIds(IStore _store, bytes32 userId, uint256 _element) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = userId;

    _store.pushToField(_tableId, _keyTuple, 15, abi.encodePacked((_element)));
  }

  /** Pop an element from catIds */
  function popCatIds(bytes32 userId) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = userId;

    StoreSwitch.popFromField(_tableId, _keyTuple, 15, 32);
  }

  /** Pop an element from catIds (using the specified store) */
  function popCatIds(IStore _store, bytes32 userId) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = userId;

    _store.popFromField(_tableId, _keyTuple, 15, 32);
  }

  /** Update an element of catIds at `_index` */
  function updateCatIds(bytes32 userId, uint256 _index, uint256 _element) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = userId;

    StoreSwitch.updateInField(_tableId, _keyTuple, 15, _index * 32, abi.encodePacked((_element)));
  }

  /** Update an element of catIds (using the specified store) at `_index` */
  function updateCatIds(IStore _store, bytes32 userId, uint256 _index, uint256 _element) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = userId;

    _store.updateInField(_tableId, _keyTuple, 15, _index * 32, abi.encodePacked((_element)));
  }

  /** Get the full data */
  function get(bytes32 userId) internal view returns (TravelData memory _table) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = userId;

    bytes memory _blob = StoreSwitch.getRecord(_tableId, _keyTuple, getSchema());
    return decode(_blob);
  }

  /** Get the full data (using the specified store) */
  function get(IStore _store, bytes32 userId) internal view returns (TravelData memory _table) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = userId;

    bytes memory _blob = _store.getRecord(_tableId, _keyTuple, getSchema());
    return decode(_blob);
  }

  /** Set the full data using individual values */
  function set(
    bytes32 userId,
    uint256 travelId,
    uint256 spotId,
    uint8 travelStatus,
    uint8 travelType,
    bytes32 rewardItemsHash,
    uint32 hunger,
    uint32 fun,
    uint256 originPhotoId,
    uint32 startTime,
    uint32 endTime,
    uint32 startWaitingDuration,
    uint256 foodId,
    bytes32 backpackItemsHash,
    uint256 randSeed,
    uint256[] memory candidateCats,
    uint256[] memory catIds
  ) internal {
    bytes memory _data = encode(
      travelId,
      spotId,
      travelStatus,
      travelType,
      rewardItemsHash,
      hunger,
      fun,
      originPhotoId,
      startTime,
      endTime,
      startWaitingDuration,
      foodId,
      backpackItemsHash,
      randSeed,
      candidateCats,
      catIds
    );

    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = userId;

    StoreSwitch.setRecord(_tableId, _keyTuple, _data);
  }

  /** Set the full data using individual values (using the specified store) */
  function set(
    IStore _store,
    bytes32 userId,
    uint256 travelId,
    uint256 spotId,
    uint8 travelStatus,
    uint8 travelType,
    bytes32 rewardItemsHash,
    uint32 hunger,
    uint32 fun,
    uint256 originPhotoId,
    uint32 startTime,
    uint32 endTime,
    uint32 startWaitingDuration,
    uint256 foodId,
    bytes32 backpackItemsHash,
    uint256 randSeed,
    uint256[] memory candidateCats,
    uint256[] memory catIds
  ) internal {
    bytes memory _data = encode(
      travelId,
      spotId,
      travelStatus,
      travelType,
      rewardItemsHash,
      hunger,
      fun,
      originPhotoId,
      startTime,
      endTime,
      startWaitingDuration,
      foodId,
      backpackItemsHash,
      randSeed,
      candidateCats,
      catIds
    );

    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = userId;

    _store.setRecord(_tableId, _keyTuple, _data);
  }

  /** Set the full data using the data struct */
  function set(bytes32 userId, TravelData memory _table) internal {
    set(
      userId,
      _table.travelId,
      _table.spotId,
      _table.travelStatus,
      _table.travelType,
      _table.rewardItemsHash,
      _table.hunger,
      _table.fun,
      _table.originPhotoId,
      _table.startTime,
      _table.endTime,
      _table.startWaitingDuration,
      _table.foodId,
      _table.backpackItemsHash,
      _table.randSeed,
      _table.candidateCats,
      _table.catIds
    );
  }

  /** Set the full data using the data struct (using the specified store) */
  function set(IStore _store, bytes32 userId, TravelData memory _table) internal {
    set(
      _store,
      userId,
      _table.travelId,
      _table.spotId,
      _table.travelStatus,
      _table.travelType,
      _table.rewardItemsHash,
      _table.hunger,
      _table.fun,
      _table.originPhotoId,
      _table.startTime,
      _table.endTime,
      _table.startWaitingDuration,
      _table.foodId,
      _table.backpackItemsHash,
      _table.randSeed,
      _table.candidateCats,
      _table.catIds
    );
  }

  /** Decode the tightly packed blob using this table's schema */
  function decode(bytes memory _blob) internal view returns (TravelData memory _table) {
    // 246 is the total byte length of static data
    PackedCounter _encodedLengths = PackedCounter.wrap(Bytes.slice32(_blob, 246));

    _table.travelId = (uint256(Bytes.slice32(_blob, 0)));

    _table.spotId = (uint256(Bytes.slice32(_blob, 32)));

    _table.travelStatus = (uint8(Bytes.slice1(_blob, 64)));

    _table.travelType = (uint8(Bytes.slice1(_blob, 65)));

    _table.rewardItemsHash = (Bytes.slice32(_blob, 66));

    _table.hunger = (uint32(Bytes.slice4(_blob, 98)));

    _table.fun = (uint32(Bytes.slice4(_blob, 102)));

    _table.originPhotoId = (uint256(Bytes.slice32(_blob, 106)));

    _table.startTime = (uint32(Bytes.slice4(_blob, 138)));

    _table.endTime = (uint32(Bytes.slice4(_blob, 142)));

    _table.startWaitingDuration = (uint32(Bytes.slice4(_blob, 146)));

    _table.foodId = (uint256(Bytes.slice32(_blob, 150)));

    _table.backpackItemsHash = (Bytes.slice32(_blob, 182));

    _table.randSeed = (uint256(Bytes.slice32(_blob, 214)));

    // Store trims the blob if dynamic fields are all empty
    if (_blob.length > 246) {
      uint256 _start;
      // skip static data length + dynamic lengths word
      uint256 _end = 278;

      _start = _end;
      _end += _encodedLengths.atIndex(0);
      _table.candidateCats = (SliceLib.getSubslice(_blob, _start, _end).decodeArray_uint256());

      _start = _end;
      _end += _encodedLengths.atIndex(1);
      _table.catIds = (SliceLib.getSubslice(_blob, _start, _end).decodeArray_uint256());
    }
  }

  /** Tightly pack full data using this table's schema */
  function encode(
    uint256 travelId,
    uint256 spotId,
    uint8 travelStatus,
    uint8 travelType,
    bytes32 rewardItemsHash,
    uint32 hunger,
    uint32 fun,
    uint256 originPhotoId,
    uint32 startTime,
    uint32 endTime,
    uint32 startWaitingDuration,
    uint256 foodId,
    bytes32 backpackItemsHash,
    uint256 randSeed,
    uint256[] memory candidateCats,
    uint256[] memory catIds
  ) internal view returns (bytes memory) {
    uint40[] memory _counters = new uint40[](2);
    _counters[0] = uint40(candidateCats.length * 32);
    _counters[1] = uint40(catIds.length * 32);
    PackedCounter _encodedLengths = PackedCounterLib.pack(_counters);

    return
      abi.encodePacked(
        travelId,
        spotId,
        travelStatus,
        travelType,
        rewardItemsHash,
        hunger,
        fun,
        originPhotoId,
        startTime,
        endTime,
        startWaitingDuration,
        foodId,
        backpackItemsHash,
        randSeed,
        _encodedLengths.unwrap(),
        EncodeArray.encode((candidateCats)),
        EncodeArray.encode((catIds))
      );
  }

  /** Encode keys as a bytes32 array using this table's schema */
  function encodeKeyTuple(bytes32 userId) internal pure returns (bytes32[] memory _keyTuple) {
    _keyTuple = new bytes32[](1);
    _keyTuple[0] = userId;
  }

  /* Delete all data for given keys */
  function deleteRecord(bytes32 userId) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = userId;

    StoreSwitch.deleteRecord(_tableId, _keyTuple);
  }

  /* Delete all data for given keys (using the specified store) */
  function deleteRecord(IStore _store, bytes32 userId) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = userId;

    _store.deleteRecord(_tableId, _keyTuple);
  }
}
